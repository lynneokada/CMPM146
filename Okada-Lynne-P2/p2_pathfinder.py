from math import inf, sqrtfrom heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    print(source_point)    navigation_edges(mesh, source_point)    # print(mesh['boxes'])    # print(mesh['adj'])    return path, boxes.keys()def dijkstras_shortest_path(initial_position, destination, graph, adj):    """ Searches for a minimal cost path through a graph using Dijkstra's algorithm.    Args:        initial_position: The initial cell from which the path extends.        destination: The end location for the path.        graph: A loaded level, containing walls, spaces, and waypoints.        adj: An adjacency function returning cells adjacent to a given cell as well as their respective edge costs.    Returns:        If a path exits, return a list containing all cells from initial_position to destination.        Otherwise, return None.    """    # The priority queue    queue = [(0, initial_position)]    # The dictionary that will be returned with the costs    distances = {}    distances[initial_position] = 0    # The dictionary that will store the backpointers    backpointers = {}    backpointers[initial_position] = None    while queue:        current_dist, current_node = heappop(queue)        # Check if current node is the destination        if current_node == destination:            # List containing all cells from initial_position to destination            path = [current_node]            # Go backwards from destination until the source using backpointers            # and add all the nodes in the shortest path into a list            current_back_node = backpointers[current_node]            while current_back_node is not None:                path.append(current_back_node)                current_back_node = backpointers[current_back_node]            return path[::-1]        # Calculate cost from current note to all the adjacent ones        for adj_node, adj_node_cost in adj(graph, current_node):            pathcost = current_dist + adj_node_cost            # If the cost is new            if adj_node not in distances or pathcost < distances[adj_node]:                distances[adj_node] = pathcost                backpointers[adj_node] = current_node                heappush(queue, (pathcost, adj_node))    return Nonedef dijkstras_shortest_path_to_all(initial_position, graph, adj):    """ Calculates the minimum cost to every reachable cell in a graph from the initial_position.    Args:        initial_position: The initial cell from which the path extends.        graph: A loaded level, containing walls, spaces, and waypoints.        adj: An adjacency function returning cells adjacent to a given cell as well as their respective edge costs.    Returns:        A dictionary, mapping destination cells to the cost of a path from the initial_position.    """    # The priority queue    queue = [(0, initial_position)]    # The dictionary that will be returned with the costs    distances = {}    distances[initial_position] = 0    while queue:        current_dist, current_node = heappop(queue)        # Calculate cost from current note to all the adjacent ones        for adj_node, adj_node_cost in adj(graph, current_node):            pathcost = current_dist + adj_node_cost            # If the cost is new            if adj_node not in distances or pathcost < distances[adj_node]:                distances[adj_node] = pathcost                heappush(queue, (pathcost, adj_node))    return distancesdef navigation_edges(mesh, source_point):    """ Provides a list of adjacent cells and their respective costs from the given cell.    Args:        level: A loaded level, containing walls, spaces, and waypoints.        cell: A target location.    Returns:        A list of tuples containing an adjacent cell's coordinates and the cost of the edge joining it and the        originating cell.        E.g. from (0,0):            [((0,1), 1),             ((1,0), 1),             ((1,1), 1.4142135623730951),             ... ]    """    adj_cel = {}    all_boxes = mesh['boxes']    print (source_point)    px = source_point[1]    py = source_point[0]    source_box = (0,0,0,0)    for box in all_boxes:        # print(box)        if px >= box[0] and px <= box[1] and py >= box[2] and py <= box[3]:            source_box = box            print("box found: ", source_box)    # boxes = mesh['adj'][source_point]    # which box is source_point in    # what boxes surround the current box    # Visit all adjacent cells    # for box in boxes:        # print(box)    # for delta_x in [-1, 0, 1]:    #     for delta_y in [-1, 0, 1]:    #         next_cell = (cell[0] + delta_x, cell[1] + delta_y)    #         if next_cell != cell and next_cell in spaces.keys():    #             # calculate the distance from cell to next_cell    #             dist = sqrt(delta_x ** 2 + delta_y ** 2) * 0.5    #             # calculate cost and add it to the dict of adjacent cells    #             adj_cel[next_cell] = dist * (spaces[cell] + spaces[next_cell])    return adj_cel.items()