from math import inf, sqrtfrom heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    navigation_edges(mesh, source_point)    # print(mesh['boxes'])    # print(mesh['adj'])    return path, boxes.keys()def dijkstras_shortest_path(initial_position, destination, graph, adj):    """ Searches for a minimal cost path through a graph using Dijkstra's algorithm.    Args:        initial_position: The initial cell from which the path extends.        destination: The end location for the path.        graph: A loaded level, containing walls, spaces, and waypoints.        adj: An adjacency function returning cells adjacent to a given cell as well as their respective edge costs.    Returns:        If a path exits, return a list containing all cells from initial_position to destination.        Otherwise, return None.    """    # The priority queue    queue = [(0, initial_position)]    # The dictionary that will be returned with the costs    distances = {}    distances[initial_position] = 0    # The dictionary that will store the backpointers    backpointers = {}    backpointers[initial_position] = None    while queue:        current_dist, current_node = heappop(queue)        # Check if current node is the destination        if current_node == destination:            # List containing all cells from initial_position to destination            path = [current_node]            # Go backwards from destination until the source using backpointers            # and add all the nodes in the shortest path into a list            current_back_node = backpointers[current_node]            while current_back_node is not None:                path.append(current_back_node)                current_back_node = backpointers[current_back_node]            return path[::-1]        # Calculate cost from current note to all the adjacent ones        for adj_node, adj_node_cost in adj(graph, current_node):            pathcost = current_dist + adj_node_cost            # If the cost is new            if adj_node not in distances or pathcost < distances[adj_node]:                distances[adj_node] = pathcost                backpointers[adj_node] = current_node                heappush(queue, (pathcost, adj_node))    return Nonedef dijkstras_shortest_path_to_all(initial_position, graph, adj):    """ Calculates the minimum cost to every reachable cell in a graph from the initial_position.    Args:        initial_position: The initial cell from which the path extends.        graph: A loaded level, containing walls, spaces, and waypoints.        adj: An adjacency function returning cells adjacent to a given cell as well as their respective edge costs.    Returns:        A dictionary, mapping destination cells to the cost of a path from the initial_position.    """    # The priority queue    queue = [(0, initial_position)]    # The dictionary that will be returned with the costs    distances = {}    distances[initial_position] = 0    while queue:        current_dist, current_node = heappop(queue)        # Calculate cost from current note to all the adjacent ones        for adj_node, adj_node_cost in adj(graph, current_node):            pathcost = current_dist + adj_node_cost            # If the cost is new            if adj_node not in distances or pathcost < distances[adj_node]:                distances[adj_node] = pathcost                heappush(queue, (pathcost, adj_node))    return distancesdef navigation_edges(mesh, source_point):    """ Provides a list of adjacent cells and their respective costs from the given cell.    Args:        level: A loaded level, containing walls, spaces, and waypoints.        cell: A target location.    Returns:        A list of tuples containing an adjacent cell's coordinates and the cost of the edge joining it and the        originating cell.        E.g. from (0,0):            [((0,1), 1),             ((1,0), 1),             ((1,1), 1.4142135623730951),             ... ]    """    adj_cel = {}    all_boxes = mesh['boxes']    adj_boxes = mesh['adj']    px = source_point[1]    py = source_point[0]    source_box = (0,0,0,0)    # find the box the source_point lies in    for box in all_boxes:        if px >= box[0] and px <= box[1] and py >= box[2] and py <= box[3]:            source_box = box            print("source box found: ", source_box)    # calculate the cost to each adj_box    for adj_box in adj_boxes[source_box]:        bx1 = adj_box[0]        by1 = adj_box[2]        bx2 = adj_box[1]        by2 = adj_box[3]        if px < bx1 and py < by1: #top left side            # distance to top left corner (bx1, by1)        elif px >= bx1 and px <= bx2 and py < by1: #top side            # distance to directly down (px, by1)        elif px > bx2 and py < by1: #top right side            # distance to top right corner (bx2, by1)        elif px > bx2 and py >= by1 and py <= by2: #right side            # distance to directly left (bx2, py)        elif px > bx2 and py > by2: #bottom right side            # distance to bottom right corner (bx2, by2)        elif px >= bx1 and px <= bx2 and py > by2 # bottom side            # distance to directly up (px, by2)        elif px < bx1 and py > by2 #bottom left side            # distance to bottom left corner (bx1, by2)        else #left side            # distance to directly right (bx1, py)    # return list of tuples (box, cost)    return adj_cel.items()